<!-- Generated by SpecStory, Markdown v2.1.0 -->

<!-- Visual Studio Code Session 8f2cf9a5-3a99-4c79-bafb-059e527faae7 (2025-12-02 09:50Z) -->

# Database design for flexible resource management app (2025-12-02 09:50Z)

_**User (2025-12-02 09:52Z)**_

i'm trying to build a flexible resource management app. the most important part is database design. i want user to be able to create Entity and then create Records for it. to be flexible as possible i think of Depth solution. Depth one would be queryable properties that are simple. Depth two work like a dump for additional information that user want to store on that record. can you review this approach and suggest drizzle schema? here take look at this pic: #file:Untitled-2024-05-23-1455.png

---

_**Agent (model copilot/claude-opus-4.5)**_

# Review of Your Depth-Based Schema Approach

Your approach is solid for building a flexible resource management system. Let me break down the pros/cons and suggest a Drizzle schema.

## Analysis

### Pros

- **Flexibility**: Users can define their own entity structures
- **Queryable Depth 1**: Core properties remain searchable/filterable
- **Schema Evolution**: No migrations needed when users add fields
- **Depth 2 JSONB**: Perfect for unstructured/nested data (interfaces, VLANs, etc.)

### Cons to Consider

- **Depth 1 Validation**: You'll need runtime validation since field types are dynamic
- **Query Complexity**: Querying JSONB Depth 1 fields requires JSON operators
- **Indexing**: May need GIN indexes on JSONB for performance

## Suggested Drizzle Schema

```typescript
import { pgTable, text, timestamp, uuid, jsonb, index } from 'drizzle-orm/pg-core'

/*-------- Entity Definition Table --------*/
// Stores the "blueprint" for each entity type (e.g., "Cisco Switch", "Server", "License")
export const entitiesTable = pgTable('entities', {
  id: uuid('id').defaultRandom().primaryKey(),
  name: text('name').notNull().unique(), // e.g., "Cisco Switch"
  description: text('description'),

  // Depth 1 schema definition - defines queryable fields and their types
  // Example: { "Name": "string", "Serial_Number": "string", "IOS_Version": "number", "Assigned": "string", "Last_Backup": "date" }
  depth1Schema: jsonb('depth1_schema').notNull().$type<Record<string, FieldType>>(),

  createdAt: timestamp('created_at').defaultNow().notNull(),
  updatedAt: timestamp('updated_at').defaultNow().notNull(),
})

/*-------- Records Table --------*/
// Stores actual resource records (instances of entities)
export const recordsTable = pgTable(
  'records',
  {
    id: uuid('id').defaultRandom().primaryKey(),
    entityId: uuid('entity_id')
      .notNull()
      .references(() => entitiesTable.id, { onDelete: 'cascade' }),

    // Depth 1: Queryable, validated properties
    // Example: { "Name": "Cisco switch 2960 floor 1", "Serial_Number": "10V45IOS19", ... }
    depth1: jsonb('depth1').notNull().$type<Record<string, Depth1Value>>(),

    // Depth 2: Additional unstructured information dump
    // Example: { "Active_Interface": [...], "VLAN_Configuration": {...}, ... }
    depth2: jsonb('depth2').$type<Record<string, unknown>>(),

    createdAt: timestamp('created_at').defaultNow().notNull(),
    updatedAt: timestamp('updated_at').defaultNow().notNull(),
  },
  (table) => ({
    entityIdIdx: index('records_entity_id_idx').on(table.entityId),
    depth1Idx: index('records_depth1_idx').using('gin', table.depth1),
  })
)
```

```typescript
/*-------- Field Type Definitions --------*/
export const FIELD_TYPES = ['string', 'number', 'date', 'boolean'] as const
export type FieldType = (typeof FIELD_TYPES)[number]

export type Depth1Value = string | number | boolean | Date | null

/*-------- Depth 1 Schema Definition --------*/
// How an entity defines its queryable fields
export type Depth1SchemaDefinition = Record<string, FieldType>

/*-------- Example Entity Schema --------*/
// For "Cisco Switch" entity:
// {
//   "Name": "string",
//   "Serial_Number": "string",
//   "IOS_Version": "number",
//   "Assigned": "string",
//   "Last_Backup": "date"
// }
```

```typescript
export * from './entities'
export * from './types'
```

## Zod Schemas for Validation

```typescript
import { createInsertSchema, createSelectSchema } from 'drizzle-zod'
import { entitiesTable, recordsTable } from '@/db/schema'
import { z } from 'zod'
import { FIELD_TYPES } from '@/db/schema/types'

/*-------- Entity Schemas --------*/
export const entitySelectSchema = createSelectSchema(entitiesTable)
export const entityInsertSchema = createInsertSchema(entitiesTable)

export const depth1SchemaDefinitionSchema = z.record(z.string(), z.enum(FIELD_TYPES))

export const entityFormSchema = z.object({
  name: z.string().min(1, 'Name is required'),
  description: z.string().optional(),
  depth1Schema: depth1SchemaDefinitionSchema,
})

/*-------- Record Schemas --------*/
export const recordSelectSchema = createSelectSchema(recordsTable)
export const recordInsertSchema = createInsertSchema(recordsTable)

// Dynamic validation based on entity's depth1Schema
export const createRecordFormSchema = (depth1Schema: Record<string, string>) => {
  const depth1Fields: Record<string, z.ZodTypeAny> = {}

  for (const [field, type] of Object.entries(depth1Schema)) {
    switch (type) {
      case 'string':
        depth1Fields[field] = z.string()
        break
      case 'number':
        depth1Fields[field] = z.coerce.number()
        break
      case 'date':
        depth1Fields[field] = z.coerce.date()
        break
      case 'boolean':
        depth1Fields[field] = z.boolean()
        break
    }
  }

  return z.object({
    depth1: z.object(depth1Fields),
    depth2: z.record(z.unknown()).optional(),
  })
}
```

## Key Recommendations

1. **Add GIN index** on `depth1` for efficient JSONB queries
2. **Consider adding a `displayName` field** in depth1Schema for UI labels
3. **Add field ordering** if you want consistent form/table layouts
4. **Consider field validation rules** (min/max, required, regex) in the schema definition

Want me to expand on any part of this design?

---

_**User (2025-12-02 09:58Z)**_

do you have any better idea that be this flexible? i want to show those Depth1 properties in a sortable table and show those Depth2 in Record specific page in very simple and raw json format.

---

_**Agent (model copilot/claude-opus-4.5)**_

# Alternative Approaches Analysis

Your current design is actually quite good for the flexibility you need. Let me suggest a few refinements and one alternative approach worth considering.

---

## Option 1: Enhanced Depth Approach (Recommended)

Your original idea, but with **field metadata** for better table control:

```typescript
import { pgTable, text, timestamp, uuid, jsonb, index, integer } from 'drizzle-orm/pg-core'

/*-------- Field Definition Type --------*/
// More control over how fields behave in tables/forms
export type FieldDefinition = {
  type: 'string' | 'number' | 'date' | 'boolean'
  label: string
  sortable?: boolean
  required?: boolean
  order: number // For consistent column ordering
}

/*-------- Entities Table --------*/
export const entitiesTable = pgTable('entities', {
  id: uuid('id').defaultRandom().primaryKey(),
  name: text('name').notNull().unique(),
  description: text('description'),
  icon: text('icon'), // Optional icon for UI

  // Enhanced schema with field metadata
  // Example: { "serial_number": { type: "string", label: "Serial Number", sortable: true, order: 1 } }
  depth1Schema: jsonb('depth1_schema').notNull().$type<Record<string, FieldDefinition>>(),

  createdAt: timestamp('created_at').defaultNow().notNull(),
  updatedAt: timestamp('updated_at').defaultNow().notNull(),
})

/*-------- Records Table --------*/
export const recordsTable = pgTable(
  'records',
  {
    id: uuid('id').defaultRandom().primaryKey(),
    entityId: uuid('entity_id')
      .notNull()
      .references(() => entitiesTable.id, { onDelete: 'cascade' }),

    // Depth 1: Flat, queryable properties
    depth1: jsonb('depth1').notNull().$type<Record<string, string | number | boolean | null>>(),

    // Depth 2: Raw JSON dump for additional data
    depth2: jsonb('depth2').$type<Record<string, unknown>>(),

    createdAt: timestamp('created_at').defaultNow().notNull(),
    updatedAt: timestamp('updated_at').defaultNow().notNull(),
  },
  (table) => ({
    entityIdIdx: index('records_entity_id_idx').on(table.entityId),
    depth1GinIdx: index('records_depth1_gin_idx').using('gin', table.depth1),
  })
)
```

---

## Option 2: EAV (Entity-Attribute-Value) Pattern

More normalized, better for complex queries but **more joins**:

```typescript
import { pgTable, text, timestamp, uuid, jsonb, index, integer, boolean } from 'drizzle-orm/pg-core'

/*-------- Entities --------*/
export const entitiesTable = pgTable('entities', {
  id: uuid('id').defaultRandom().primaryKey(),
  name: text('name').notNull().unique(),
  description: text('description'),
  createdAt: timestamp('created_at').defaultNow().notNull(),
})

/*-------- Entity Fields (Schema Definition) --------*/
export const entityFieldsTable = pgTable(
  'entity_fields',
  {
    id: uuid('id').defaultRandom().primaryKey(),
    entityId: uuid('entity_id')
      .notNull()
      .references(() => entitiesTable.id, { onDelete: 'cascade' }),
    name: text('name').notNull(), // e.g., "serial_number"
    label: text('label').notNull(), // e.g., "Serial Number"
    type: text('type').notNull().$type<'string' | 'number' | 'date' | 'boolean'>(),
    isDepth1: boolean('is_depth1').default(true).notNull(), // Queryable?
    sortable: boolean('sortable').default(true),
    required: boolean('required').default(false),
    order: integer('order').default(0),
    createdAt: timestamp('created_at').defaultNow().notNull(),
  },
  (table) => ({
    entityFieldIdx: index('entity_fields_entity_idx').on(table.entityId),
  })
)

/*-------- Records --------*/
export const recordsTable = pgTable('records', {
  id: uuid('id').defaultRandom().primaryKey(),
  entityId: uuid('entity_id')
    .notNull()
    .references(() => entitiesTable.id, { onDelete: 'cascade' }),
  createdAt: timestamp('created_at').defaultNow().notNull(),
  updatedAt: timestamp('updated_at').defaultNow().notNull(),
})

/*-------- Record Values (EAV) --------*/
export const recordValuesTable = pgTable(
  'record_values',
  {
    id: uuid('id').defaultRandom().primaryKey(),
    recordId: uuid('record_id')
      .notNull()
      .references(() => recordsTable.id, { onDelete: 'cascade' }),
    fieldId: uuid('field_id')
      .notNull()
      .references(() => entityFieldsTable.id, { onDelete: 'cascade' }),
    value: text('value'), // All values stored as text, parsed by type
  },
  (table) => ({
    recordValueIdx: index('record_values_record_idx').on(table.recordId),
    fieldValueIdx: index('record_values_field_idx').on(table.fieldId),
  })
)

/*-------- Depth 2 Data (Separate table for raw JSON) --------*/
export const recordMetadataTable = pgTable('record_metadata', {
  id: uuid('id').defaultRandom().primaryKey(),
  recordId: uuid('record_id')
    .notNull()
    .references(() => recordsTable.id, { onDelete: 'cascade' })
    .unique(),
  data: jsonb('data').$type<Record<string, unknown>>(),
})
```

---

## Comparison

| Aspect               | Option 1 (JSONB Depth) | Option 2 (EAV)          |
| -------------------- | ---------------------- | ----------------------- |
| **Query Simplicity** | ✅ Single table query  | ❌ Multiple joins       |
| **Sorting in DB**    | ⚠️ JSONB operators     | ✅ Native column sort   |
| **Schema Changes**   | ✅ Just update JSON    | ✅ Add/remove rows      |
| **Performance**      | ✅ Good with GIN index | ⚠️ Many rows per record |
| **Flexibility**      | ✅ Excellent           | ✅ Excellent            |
| **Complexity**       | ✅ Simple              | ❌ More complex         |

---

## My Recommendation: Option 1 with Enhancements

For your use case (sortable table + raw JSON display), **Option 1** is better because:

1. **TanStack Table** can handle client-side sorting on JSONB fields easily
2. **Fewer queries** - one query gets everything
3. **Depth2 is already JSON** - perfect for raw display

Here's the complete schema with types:

```typescript
/*-------- Field Types --------*/
export const FIELD_TYPES = ['string', 'number', 'date', 'boolean'] as const
export type FieldType = (typeof FIELD_TYPES)[number]

/*-------- Field Definition --------*/
export type FieldDefinition = {
  type: FieldType
  label: string
  sortable: boolean
  required: boolean
  order: number
}

/*-------- Depth 1 Schema --------*/
export type Depth1Schema = Record<string, FieldDefinition>

/*-------- Depth 1 Value --------*/
export type Depth1Value = string | number | boolean | null

/*-------- Depth 1 Data --------*/
export type Depth1Data = Record<string, Depth1Value>

/*-------- Depth 2 Data --------*/
export type Depth2Data = Record<string, unknown>
```

```typescript
import { pgTable, text, timestamp, uuid, jsonb, index } from 'drizzle-orm/pg-core'
import type { Depth1Schema, Depth1Data, Depth2Data } from './types'

/*-------- Entities Table --------*/
export const entitiesTable = pgTable('entities', {
  id: uuid('id').defaultRandom().primaryKey(),
  name: text('name').notNull().unique(),
  description: text('description'),
  icon: text('icon'),
  depth1Schema: jsonb('depth1_schema').notNull().$type<Depth1Schema>(),
  createdAt: timestamp('created_at').defaultNow().notNull(),
  updatedAt: timestamp('updated_at').defaultNow().notNull(),
})

/*-------- Records Table --------*/
export const recordsTable = pgTable(
  'records',
  {
    id: uuid('id').defaultRandom().primaryKey(),
    entityId: uuid('entity_id')
      .notNull()
      .references(() => entitiesTable.id, { onDelete: 'cascade' }),
    depth1: jsonb('depth1').notNull().$type<Depth1Data>(),
    depth2: jsonb('depth2').$type<Depth2Data>(),
    createdAt: timestamp('created_at').defaultNow().notNull(),
    updatedAt: timestamp('updated_at').defaultNow().notNull(),
  },
  (table) => ({
    entityIdIdx: index('records_entity_id_idx').on(table.entityId),
    depth1GinIdx: index('records_depth1_gin_idx').using('gin', table.depth1),
  })
)
```

```typescript
export * from './types'
export * from './entities'
```

```typescript
import { createInsertSchema, createSelectSchema } from 'drizzle-zod'
import { entitiesTable, recordsTable } from '@/db/schema'
import { z } from 'zod'
import { FIELD_TYPES } from '@/db/schema/types'

/*-------- Entity Schemas --------*/
export const entitySelectSchema = createSelectSchema(entitiesTable)
export const entityInsertSchema = createInsertSchema(entitiesTable)

/*-------- Field Definition Schema --------*/
export const fieldDefinitionSchema = z.object({
  type: z.enum(FIELD_TYPES),
  label: z.string().min(1),
  sortable: z.boolean().default(true),
  required: z.boolean().default(false),
  order: z.number().int().min(0),
})

/*-------- Entity Form Schema --------*/
export const entityFormSchema = z.object({
  name: z.string().min(1, 'Name is required'),
  description: z.string().optional(),
  icon: z.string().optional(),
  depth1Schema: z.record(z.string(), fieldDefinitionSchema),
})

/*-------- Record Schemas --------*/
export const recordSelectSchema = createSelectSchema(recordsTable)
export const recordInsertSchema = createInsertSchema(recordsTable)

/*-------- Dynamic Record Form Schema --------*/
export const createRecordFormSchema = (
  depth1Schema: Record<string, { type: string; required: boolean }>
) => {
  const depth1Fields: Record<string, z.ZodTypeAny> = {}

  for (const [fieldKey, fieldDef] of Object.entries(depth1Schema)) {
    let fieldSchema: z.ZodTypeAny

    switch (fieldDef.type) {
      case 'string':
        fieldSchema = z.string()
        break
      case 'number':
        fieldSchema = z.coerce.number()
        break
      case 'date':
        fieldSchema = z.coerce.date()
        break
      case 'boolean':
        fieldSchema = z.boolean()
        break
      default:
        fieldSchema = z.string()
    }

    depth1Fields[fieldKey] = fieldDef.required ? fieldSchema : fieldSchema.nullable().optional()
  }

  return z.object({
    depth1: z.object(depth1Fields),
    depth2: z.record(z.unknown()).optional(),
  })
}
```

```typescript
import { z } from 'zod'
import {
  entitySelectSchema,
  entityFormSchema,
  recordSelectSchema,
  fieldDefinitionSchema,
} from './schemas'

export type Entity = z.infer<typeof entitySelectSchema>
export type EntityFormData = z.infer<typeof entityFormSchema>
export type Record = z.infer<typeof recordSelectSchema>
export type FieldDefinition = z.infer<typeof fieldDefinitionSchema>
```

This gives you:

- **Sortable columns** from `depth1Schema` with `sortable: true`
- **Ordered columns** via `order` field
- **Proper labels** for table headers
- **Type-safe validation** at runtime
- **Depth2 as raw JSON** for the detail page

Want me to show how to build the dynamic TanStack Table columns from this schema?

---

_**User (2025-12-02 17:12Z)**_

yep enhanced version is good. now i have question. how can i setup a zod modification for a Depth 1 property? like a min and max for Age or email for Email or etc.

---

_**Agent (model copilot/claude-opus-4.5)**_

Great question! You need to extend the `FieldDefinition` to include **validation rules** that map to Zod modifiers. Here's how:

## Enhanced Field Definition with Validation Rules

```typescript
/*-------- Field Types --------*/
export const FIELD_TYPES = ['string', 'number', 'date', 'boolean'] as const
export type FieldType = (typeof FIELD_TYPES)[number]

/*-------- Validation Rules per Type --------*/
export type StringValidation = {
  minLength?: number
  maxLength?: number
  pattern?: 'email' | 'url' | 'uuid' | 'regex'
  regex?: string // Custom regex when pattern is "regex"
}

export type NumberValidation = {
  min?: number
  max?: number
  integer?: boolean
}

export type DateValidation = {
  minDate?: string // ISO string
  maxDate?: string // ISO string
}

export type BooleanValidation = Record<string, never> // No validation needed

/*-------- Validation Map --------*/
export type ValidationRules = {
  string: StringValidation
  number: NumberValidation
  date: DateValidation
  boolean: BooleanValidation
}

/*-------- Field Definition --------*/
export type FieldDefinition<T extends FieldType = FieldType> = {
  type: T
  label: string
  sortable: boolean
  required: boolean
  order: number
  validation?: ValidationRules[T]
}

/*-------- Depth 1 Schema --------*/
export type Depth1Schema = Record<string, FieldDefinition>

/*-------- Depth 1 Value --------*/
export type Depth1Value = string | number | boolean | null

/*-------- Depth 1 Data --------*/
export type Depth1Data = Record<string, Depth1Value>

/*-------- Depth 2 Data --------*/
export type Depth2Data = Record<string, unknown>
```

## Zod Schema Builder

```typescript
import { createInsertSchema, createSelectSchema } from 'drizzle-zod'
import { entitiesTable, recordsTable } from '@/db/schema'
import { z } from 'zod'
import {
  FIELD_TYPES,
  type FieldDefinition,
  type Depth1Schema,
  type StringValidation,
  type NumberValidation,
  type DateValidation,
} from '@/db/schema/types'

/*-------- Entity Schemas --------*/
export const entitySelectSchema = createSelectSchema(entitiesTable)
export const entityInsertSchema = createInsertSchema(entitiesTable)

/*-------- Validation Schemas --------*/
export const stringValidationSchema = z.object({
  minLength: z.number().int().min(0).optional(),
  maxLength: z.number().int().min(1).optional(),
  pattern: z.enum(['email', 'url', 'uuid', 'regex']).optional(),
  regex: z.string().optional(),
})

export const numberValidationSchema = z.object({
  min: z.number().optional(),
  max: z.number().optional(),
  integer: z.boolean().optional(),
})

export const dateValidationSchema = z.object({
  minDate: z.string().optional(),
  maxDate: z.string().optional(),
})

/*-------- Field Definition Schema --------*/
export const fieldDefinitionSchema = z.object({
  type: z.enum(FIELD_TYPES),
  label: z.string().min(1),
  sortable: z.boolean().default(true),
  required: z.boolean().default(false),
  order: z.number().int().min(0),
  validation: z
    .union([stringValidationSchema, numberValidationSchema, dateValidationSchema, z.object({})])
    .optional(),
})

/*-------- Entity Form Schema --------*/
export const entityFormSchema = z.object({
  name: z.string().min(1, 'Name is required'),
  description: z.string().optional(),
  icon: z.string().optional(),
  depth1Schema: z.record(z.string(), fieldDefinitionSchema),
})

/*-------- Record Schemas --------*/
export const recordSelectSchema = createSelectSchema(recordsTable)
export const recordInsertSchema = createInsertSchema(recordsTable)

/*-------- String Field Builder --------*/
function buildStringSchema(validation?: StringValidation): z.ZodString {
  let schema = z.string()

  if (!validation) return schema

  if (validation.minLength !== undefined) {
    schema = schema.min(validation.minLength, `Minimum ${validation.minLength} characters`)
  }

  if (validation.maxLength !== undefined) {
    schema = schema.max(validation.maxLength, `Maximum ${validation.maxLength} characters`)
  }

  if (validation.pattern) {
    switch (validation.pattern) {
      case 'email':
        schema = schema.email('Invalid email format')
        break
      case 'url':
        schema = schema.url('Invalid URL format')
        break
      case 'uuid':
        schema = schema.uuid('Invalid UUID format')
        break
      case 'regex':
        if (validation.regex) {
          schema = schema.regex(new RegExp(validation.regex), 'Invalid format')
        }
        break
    }
  }

  return schema
}

/*-------- Number Field Builder --------*/
function buildNumberSchema(validation?: NumberValidation): z.ZodNumber {
  let schema = z.coerce.number()

  if (!validation) return schema

  if (validation.integer) {
    schema = schema.int('Must be a whole number')
  }

  if (validation.min !== undefined) {
    schema = schema.min(validation.min, `Minimum value is ${validation.min}`)
  }

  if (validation.max !== undefined) {
    schema = schema.max(validation.max, `Maximum value is ${validation.max}`)
  }

  return schema
}

/*-------- Date Field Builder --------*/
function buildDateSchema(validation?: DateValidation): z.ZodDate {
  let schema = z.coerce.date()

  if (!validation) return schema

  if (validation.minDate) {
    schema = schema.min(new Date(validation.minDate), `Date must be after ${validation.minDate}`)
  }

  if (validation.maxDate) {
    schema = schema.max(new Date(validation.maxDate), `Date must be before ${validation.maxDate}`)
  }

  return schema
}

/*-------- Dynamic Record Form Schema Builder --------*/
export function createRecordFormSchema(depth1Schema: Depth1Schema) {
  const depth1Fields: Record<string, z.ZodTypeAny> = {}

  for (const [fieldKey, fieldDef] of Object.entries(depth1Schema)) {
    let fieldSchema: z.ZodTypeAny

    switch (fieldDef.type) {
      case 'string':
        fieldSchema = buildStringSchema(fieldDef.validation as StringValidation)
        break
      case 'number':
        fieldSchema = buildNumberSchema(fieldDef.validation as NumberValidation)
        break
      case 'date':
        fieldSchema = buildDateSchema(fieldDef.validation as DateValidation)
        break
      case 'boolean':
        fieldSchema = z.boolean()
        break
      default:
        fieldSchema = z.string()
    }

    // Handle required/optional
    depth1Fields[fieldKey] = fieldDef.required ? fieldSchema : fieldSchema.nullable().optional()
  }

  return z.object({
    depth1: z.object(depth1Fields),
    depth2: z.record(z.unknown()).optional(),
  })
}
```

## Example Usage

```typescript
import { createRecordFormSchema } from './schemas'
import type { Depth1Schema } from '@/db/schema/types'

/*-------- Example Entity Schema --------*/
const ciscoSwitchSchema: Depth1Schema = {
  name: {
    type: 'string',
    label: 'Name',
    sortable: true,
    required: true,
    order: 0,
    validation: {
      minLength: 3,
      maxLength: 100,
    },
  },
  serial_number: {
    type: 'string',
    label: 'Serial Number',
    sortable: true,
    required: true,
    order: 1,
    validation: {
      pattern: 'regex',
      regex: '^[A-Z0-9]{10,}$', // Alphanumeric, min 10 chars
    },
  },
  admin_email: {
    type: 'string',
    label: 'Admin Email',
    sortable: false,
    required: false,
    order: 2,
    validation: {
      pattern: 'email',
    },
  },
  port_count: {
    type: 'number',
    label: 'Port Count',
    sortable: true,
    required: true,
    order: 3,
    validation: {
      min: 1,
      max: 96,
      integer: true,
    },
  },
  purchase_date: {
    type: 'date',
    label: 'Purchase Date',
    sortable: true,
    required: false,
    order: 4,
    validation: {
      minDate: '2000-01-01',
      maxDate: new Date().toISOString().split('T')[0], // Today
    },
  },
  is_active: {
    type: 'boolean',
    label: 'Active',
    sortable: true,
    required: true,
    order: 5,
  },
}

/*-------- Generate Zod Schema --------*/
const recordSchema = createRecordFormSchema(ciscoSwitchSchema)

/*-------- Validate Data --------*/
const result = recordSchema.safeParse({
  depth1: {
    name: 'Cisco 2960 Floor 1',
    serial_number: 'FOC1234ABCD',
    admin_email: 'admin@company.com',
    port_count: 24,
    purchase_date: '2023-06-15',
    is_active: true,
  },
  depth2: {
    vlans: [{ id: 10, name: 'Management' }],
    interfaces: [],
  },
})

if (!result.success) {
  console.log(result.error.flatten())
}
```

## Summary

| Field Type | Available Validations                                               |
| ---------- | ------------------------------------------------------------------- |
| `string`   | `minLength`, `maxLength`, `pattern` (email/url/uuid/regex), `regex` |
| `number`   | `min`, `max`, `integer`                                             |
| `date`     | `minDate`, `maxDate`                                                |
| `boolean`  | None needed                                                         |

This approach gives you:

- **Type-safe validation rules** per field type
- **Dynamic Zod schema generation** based on entity definition
- **Extensible** - easy to add more validation rules later

Want me to show how to build a UI for configuring these validation rules when creating an entity?

---
